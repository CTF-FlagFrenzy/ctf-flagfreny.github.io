---
title: "CTF Blockchain-Challenge | Solana Dumb Contract: Expert Level"
description: Solana Dumb Contract challenge
---

The Solana Dumb Contract is a simple Solana program that manages a flag value with basic access control. The contract stores a hash of a flag and allows only an admin to unlock it. Once unlocked, the flag can be retrieved by anyone.

The contract serves as a good example of:
- Basic Solana program structure
- Account data management
- Simple access control mechanisms
- Instruction processing

## Contract Structure

The contract is written in Rust and uses the Solana Program SDK. Here's the main structure:

```rust
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program_error::ProgramError,
    pubkey::Pubkey,
    program_pack::{IsInitialized, Pack, Sealed},
    hash::{hash, Hash},
};
use arrayref::{array_ref, array_refs, array_mut_ref, mut_array_refs};
use borsh::{BorshDeserialize, BorshSerialize};

// State structure
#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct FlagState {
    pub admin: Pubkey,
    pub flag_hash: [u8; 32],
    pub unlocked: bool,
}

// Program entrypoint
entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    // Instruction processing logic
}
```

## State Management

The contract maintains state in a `FlagState` structure that is stored in a dedicated account. This structure implements the Solana `Pack` trait for serialization and deserialization:

```rust
impl Pack for FlagState {
    const LEN: usize = 32 + 32 + 1; // Admin (32) + Flag Hash (32) + Unlocked (1)

    fn unpack_from_slice(src: &[u8]) -> Result<Self, ProgramError> {
        let src = array_ref![src, 0, 32 + 32 + 1];
        let (admin_bytes, flag_hash_bytes, unlocked_bytes) = array_refs![src, 32, 32, 1];

        Ok(FlagState {
            admin: Pubkey::new_from_array(*admin_bytes),
            flag_hash: *flag_hash_bytes,
            unlocked: unlocked_bytes[0] != 0,
        })
    }

    fn pack_into_slice(&self, dst: &mut [u8]) {
        let dst = array_mut_ref![dst, 0, 32 + 32 + 1];
        let (admin_dst, flag_hash_dst, unlocked_dst) = mut_array_refs![dst, 32, 32, 1];

        admin_dst.copy_from_slice(self.admin.as_ref());
        flag_hash_dst.copy_from_slice(&self.flag_hash);
        unlocked_dst[0] = self.unlocked as u8;
    }
}
```

The state consists of:
- `admin`: The public key of the account that can unlock the flag
- `flag_hash`: A hash of the flag value
- `unlocked`: A boolean indicating whether the flag is unlocked

## Instructions

The contract supports three instructions:

### 1. Initialize (Empty instruction data)

This instruction initializes the contract state:
- Sets the calling account as the admin
- Sets the flag hash
- Sets the unlocked state to false

```rust
if instruction_data.is_empty() {
    msg!("Initializing...");
    flag_state.admin = *signer_account.key;
    flag_state.flag_hash = hash(b"FF{e7aa71973d5c4703ef39648833eb8c892dfsdf402edc52b7a2944ad9830b22dac}").to_bytes();
    flag_state.unlocked = false;
    FlagState::pack_into_slice(&flag_state, &mut flag_account.data.borrow_mut());
    return Ok(());
}
```

### 2. Unlock Flag (Instruction data: `[1]`)

This instruction unlocks the flag, but only if called by the admin:

```rust
if signer_account.key == &flag_state.admin && instruction_data.len() == 1 && instruction_data[0] == 1 {
    msg!("Unlock");
    flag_state.unlocked = true;
    FlagState::pack_into_slice(&flag_state, &mut flag_account.data.borrow_mut());
    return Ok(());
}
```

### 3. Retrieve Flag (Instruction data: `[2]`)

This instruction retrieves the flag, but only if it has been unlocked:

```rust
if instruction_data.len() == 1 && instruction_data[0] == 2 && flag_state.unlocked {
    msg!("FF{e7aa71973d5c4703ef39648833eb8c892dfsdf402edc52b7a2944ad9830b22dac}");
    return Ok(());
}
```

## Deployment Guide

To deploy the Solana Dumb Contract to the Solana blockchain, follow these steps:

### Prerequisites
- Install Rust and Cargo
- Install Solana CLI tools
- Configure Solana CLI to use the desired network (e.g., devnet, testnet)

### Build the Program

1. Clone the repository containing the contract code
2. Build the program using the Solana BPF toolchain:

```bash
# In the directory containing lib.rs
cargo build-bpf
```

This will create a compiled `.so` file in the `target` directory.

### Deploy the Program

Deploy the compiled program to the Solana blockchain:

```bash
solana program deploy target/deploy/solana_dumb_contract.so
```

This command will output the Program ID, which you'll need for client interactions.

## Client Interaction

The contract can be interacted with using the Solana web3.js library. Here's a TypeScript example demonstrating how to interact with the contract:

```typescript
import * as web3 from '@solana/web3.js';

async function interactWithContract() {
    // Connect to the Solana network
    const connection = new web3.Connection(web3.clusterApiUrl('devnet'));
    
    // Replace with your program ID
    const programId = new web3.PublicKey("JAZcYm2mHoEwuPz7wAv4xG8o48gCtwXv7FNbj7Bt88z");
    
    // Create or import a keypair for the payer account
    const payer = web3.Keypair.generate();
    
    // Create a keypair for the flag account
    const flagAccount = web3.Keypair.generate();
    
    // Calculate the minimum lamports needed for rent exemption
    const lamports = await connection.getMinimumBalanceForRentExemption(65); // 32 + 32 + 1 = FlagState::LEN
    
    // Create the flag account
    const createAccountInstruction = web3.SystemProgram.createAccount({
        fromPubkey: payer.publicKey,
        newAccountPubkey: flagAccount.publicKey,
        lamports,
        space: 65,
        programId,
    });
    
    // Send transaction to create the account
    await web3.sendAndConfirmTransaction(
        connection, 
        new web3.Transaction().add(createAccountInstruction), 
        [payer, flagAccount]
    );
    
    // Initialize the contract
    const initInstruction = new web3.TransactionInstruction({
        keys: [
            { pubkey: flagAccount.publicKey, isSigner: false, isWritable: true },
            { pubkey: payer.publicKey, isSigner: true, isWritable: true }
        ],
        programId,
        data: Buffer.from([]),
    });
    
    await web3.sendAndConfirmTransaction(
        connection, 
        new web3.Transaction().add(initInstruction), 
        [payer]
    );
    
    // Unlock the flag
    const unlockInstruction = new web3.TransactionInstruction({
        keys: [
            { pubkey: flagAccount.publicKey, isSigner: false, isWritable: true },
            { pubkey: payer.publicKey, isSigner: true, isWritable: true }
        ],
        programId,
        data: Buffer.from([1]),
    });
    
    await web3.sendAndConfirmTransaction(
        connection, 
        new web3.Transaction().add(unlockInstruction), 
        [payer]
    );
    
    // Retrieve the flag
    const retrieveFlagInstruction = new web3.TransactionInstruction({
        keys: [
            { pubkey: flagAccount.publicKey, isSigner: false, isWritable: false },
            { pubkey: payer.publicKey, isSigner: true, isWritable: true }
        ],
        programId,
        data: Buffer.from([2]),
    });
    
    await web3.sendAndConfirmTransaction(
        connection, 
        new web3.Transaction().add(retrieveFlagInstruction), 
        [payer]
    );
    
    // To see the flag, you need to check the transaction logs
    console.log("Check transaction logs for the flag");
}
```

## Security Considerations

The Solana Dumb Contract, while simple, demonstrates some security patterns but also has limitations:

### Positive Security Aspects
- Validates the program ID in the account ownership check
- Implements access control for the unlock operation

### Security Considerations
1. The flag is hardcoded in the program, which is visible in the blockchain
2. The contract uses a simple boolean for access control rather than more sophisticated mechanisms
3. There's no time-based locking or other advanced security features

### Best Practices for Production
For a production version of this contract, consider:
- Using on-chain encryption for sensitive data
- Implementing multi-signature requirements for critical operations
- Adding time-locks or other security constraints
- Proper error handling with specific error codes

## Conclusion

The Solana Dumb Contract demonstrates fundamental concepts in Solana program development, including account management, state serialization, and instruction processing. While simple, it provides a foundation for understanding more complex Solana programs.

**HAVE FUN**

## Challenge Writeup

1. Initialize the contract with no instruction data
2. Unlock the flag (instruction data `[1]`) - only the admin can do this
3. Retrieve the flag (instruction data `[2]`) - only works if the flag is unlocked

The flag is stored directly in the contract code, and the contract prints it when requested.

## Solution Method 1: Using Solana CLI

I'll demonstrate how to solve this challenge by directly interacting with the contract using the Solana CLI.

### Step 1: Setup Environment

First, set up the Solana CLI to use the devnet cluster:

```bash
solana config set --url devnet
```

### Step 2: Create a Keypair for the Payer Account

We'll create a keypair file for our payer account that will match the one used in the client code:

```bash
# Save the private key from the client code to a file
echo "[255,6,113,136,24,155,19,63,23,42,109,25,97,109,133,134,100,146,235,249,183,172,98,207,28,225,46,45,150,231,166,30,78,72,190,139,242,73,53,140,32,28,221,233,247,186,121,9,221,13,96,40,52,25,218,16,102,143,129,173,132,45,95,239]" > payer_array.json

# Convert the JSON array to a binary keypair file
solana-keygen recover -o payer.json 'prompt:?key=array:255,6,113,136,24,155,19,63,23,42,109,25,97,109,133,134,100,146,235,249,183,172,98,207,28,225,46,45,150,231,166,30,78,72,190,139,242,73,53,140,32,28,221,233,247,186,121,9,221,13,96,40,52,25,218,16,102,143,129,173,132,45,95,239'
```

### Step 3: Fund the Payer Account

We need SOL in our payer account to pay for transactions:

```bash
solana airdrop 2 $(solana address -k payer.json)
```

### Step 4: Create a Flag Account

Generate a new keypair for the flag account:

```bash
solana-keygen new -o flag_account.json
```

Then create the account and allocate space for the flag state (65 bytes: 32 for admin + 32 for flag hash + 1 for unlocked flag):

::::tip
Use the account size 65 (information in description)
::::

```bash
solana create-account \
  --from payer.json \
  --keypair flag_account.json \
  --lamports $(solana minimum-balance-for-rent-exemption 65) \
  --space 65 \
  --program-id JAZcYm2mHoEwuPz7wAv4xG8o48gCtwXv7FNbj7Bt88z
```

### Step 5: Initialize the Contract

Initialize the contract by sending an empty instruction:

```bash
solana program invoke \
  --program-id JAZcYm2mHoEwuPz7wAv4xG8o48gCtwXv7FNbj7Bt88z \
  --keypair payer.json \
  '' \
  $(solana address -k flag_account.json) \
  $(solana address -k payer.json)
```

This calls the contract with no instruction data, which triggers the initialization code path. The contract sets our payer as the admin and initializes the flag state.

### Step 6: Unlock the Flag

Send instruction data `[1]` to unlock the flag:

```bash
solana program invoke \
  --program-id JAZcYm2mHoEwuPz7wAv4xG8o48gCtwXv7FNbj7Bt88z \
  --keypair payer.json \
  '01' \
  $(solana address -k flag_account.json) \
  $(solana address -k payer.json)
```

### Step 7: Retrieve the Flag

Finally, send instruction data `[2]` to retrieve the flag:

```bash
solana program invoke \
  --program-id JAZcYm2mHoEwuPz7wAv4xG8o48gCtwXv7FNbj7Bt88z \
  --keypair payer.json \
  '02' \
  $(solana address -k flag_account.json) \
  $(solana address -k payer.json)
```

The contract will print the flag in the program logs, which can be viewed either in the output of the command or by running:

```bash
solana logs | grep "FF{"
```

### The Flag

After executing the retrieve flag instruction, we can see that the flag is:

```
FF{e7aa71973d5c4703ef39648833eb8c892dfsdf402edc52b7a2944ad9830b22dac}
```

## Solution Method 2: Analyzing the Contract Source Code

Instead of interacting with the contract, we can directly analyze the source code to extract the flag. This approach is much faster and doesn't require going through the initialization and unlocking process.

### Step 1: Dump the Contract Binary

First, we need to download the compiled contract from the blockchain:

```bash
# Create a directory to store the program binary
mkdir -p program_dump

# Dump the program binary from the chain
solana program dump JAZcYm2mHoEwuPz7wAv4xG8o48gCtwXv7FNbj7Bt88z program_dump/dumb_contract.so
```

### Step 2: Disassemble or Analyze the Binary

Once we have the binary, we can use tools to analyze it:

```bash
# For ELF binaries, we can view strings that might contain the flag
strings program_dump/dumb_contract.so | grep -i "FF{"

# Or disassemble the binary to look at its instructions
objdump -d program_dump/dumb_contract.so > program_dump/disassembly.txt
```

### Step 3: Locate the Flag in the Code

In this case, looking through the binary or disassembly, we can find the flag embedded directly in the code:

```
FF{e7aa71973d5c4703ef39648833eb8c892dfsdf402edc52b7a2944ad9830b22dac}
```

This approach bypasses the need to interact with the contract completely, allowing us to extract the flag directly from the program binary. 

If the source code is available (as it was in this challenge), we can also directly examine it to find where the flag might be hidden:

```rust
    if instruction_data.len() == 1 && instruction_data[0] == 2 && flag_state.unlocked {
        msg!("FF{e7aa71973d5c4703ef39648833eb8c892dfsdf402edc52b7a2944ad9830b22dac}");
        return Ok(());
    }
```

### Step 4: Verify the Flag Format

The flag follows the expected format `FF{...}`, confirming that our extraction was correct.
